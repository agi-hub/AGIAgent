#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
JSON parsing and fixing utilities.

This module contains utility functions for parsing and fixing malformed JSON strings,
particularly those generated by language models that may contain escape issues or
structural problems.

Migrated from tool_executor.py for better code organization and reusability.
"""

import json
import re
from typing import Dict, Any, Optional


def _log_warning(message: str) -> None:
    """
    Simple logging function to replace print_current dependency.
    
    Args:
        message: Warning message to log
    """
    try:
        # Try to import print_current if available
        from tools.print_system import print_current
        print_current(message)
    except ImportError:
        # Fallback to standard print if print_current is not available
        print(message)


def fix_json_escapes(json_str: str) -> str:
    """
    Simplified JSON escape function - just returns the original string.
    Complex regex processing has been removed to avoid catastrophic backtracking.
    
    Args:
        json_str: Raw JSON string
        
    Returns:
        Original JSON string (no processing)
    """
    return json_str


def smart_escape_quotes_in_json_values(json_str: str) -> str:
    """
    Smart method to escape unescaped quotes in JSON values while preserving JSON structure.
    
    This method uses a simple but effective approach: find JSON values and escape quotes within them.
    
    Args:
        json_str: Raw JSON string that may have unescaped quotes in values
        
    Returns:
        JSON string with properly escaped quotes in values
    """
    try:
        # More robust approach: find JSON string values and escape unescaped characters
        # This handles multiline strings with unescaped newlines, quotes, etc.
        
        def escape_value_quotes(match):
            prefix = match.group(1)  # "field": "
            content = match.group(2)  # content that may contain quotes, newlines, etc.
            
            # Escape unescaped quotes in the content
            escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
            
            # Also escape other common problematic characters (newlines, tabs, carriage returns)
            escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
            escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
            escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
            
            return f'{prefix}{escaped_content}"'
        
        # Improved pattern: matches "field": "value" where value can contain newlines
        # Uses non-greedy matching with DOTALL flag to handle multiline strings
        # The pattern looks for: "field": "content" where content may span multiple lines
        pattern = r'("[^"]*"\s*:\s*")(.*?)(?="\s*[,}])'
        
        fixed_json = re.sub(pattern, escape_value_quotes, json_str, flags=re.DOTALL)
        
        # Handle edge case: if the pattern didn't match properly, try a different approach
        if fixed_json == json_str:
            # Alternative approach: specifically target code_edit field which commonly has this issue
            # This handles SVG XML content and other complex content with multiline strings
            code_edit_pattern = r'("code_edit"\s*:\s*")(.*?)(?="\s*[,}])'
            def fix_code_edit_quotes(match):
                prefix = match.group(1)
                content = match.group(2)
                # Escape unescaped quotes, but preserve SVG/XML structure
                escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
                # Also escape newlines and tabs for JSON compatibility
                escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                return f'{prefix}{escaped_content}"'
            
            fixed_json = re.sub(code_edit_pattern, fix_code_edit_quotes, json_str, flags=re.DOTALL)
            
            # If still not fixed, try handling any field that contains XML-like content
            if fixed_json == json_str:
                # Pattern to match any field value that contains XML/SVG tags
                xml_content_pattern = r'("[\w_]+"\s*:\s*")(.*?<svg.*?>.*?)(?="\s*[,}])'
                def fix_xml_content_quotes(match):
                    prefix = match.group(1)
                    content = match.group(2)
                    # Escape unescaped quotes in XML content
                    escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
                    escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                    escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                    escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                    return f'{prefix}{escaped_content}"'
                
                fixed_json = re.sub(xml_content_pattern, fix_xml_content_quotes, json_str, flags=re.DOTALL)
        
        # If still not fixed, try a more aggressive approach: find unescaped newlines in string values
        # This handles cases where the string doesn't have a proper closing quote
        if fixed_json == json_str:
            # Look for patterns like "field": "value with\nnewline" where the newline is not escaped
            # and try to escape it
            lines = json_str.split('\n')
            fixed_lines = []
            in_string_value = False
            string_start_key = None
            
            for i, line in enumerate(lines):
                # Check if this line starts a string value
                string_value_match = re.match(r'(\s*"[^"]*"\s*:\s*")(.*)', line)
                if string_value_match:
                    in_string_value = True
                    string_start_key = string_value_match.group(1)
                    content = string_value_match.group(2)
                    # Check if the line ends with a closing quote
                    if re.search(r'"\s*[,}]', line):
                        # String ends on this line
                        escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
                        escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                        fixed_lines.append(f'{string_start_key}{escaped_content}')
                        in_string_value = False
                        string_start_key = None
                    else:
                        # String continues on next line(s)
                        fixed_lines.append(line)
                elif in_string_value:
                    # This line is part of a multiline string value
                    # Check if this line ends the string
                    if re.search(r'"\s*[,}]', line):
                        # String ends on this line
                        escaped_content = re.sub(r'(?<!\\)"', '\\"', line)
                        escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                        fixed_lines.append(escaped_content.replace('\n', '\\n'))
                        in_string_value = False
                        string_start_key = None
                    else:
                        # Still in the string value, escape the line
                        escaped_line = line.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r')
                        fixed_lines.append(escaped_line)
                else:
                    fixed_lines.append(line)
            
            if fixed_lines != lines:
                fixed_json = '\n'.join(fixed_lines)
        
        return fixed_json
        
    except Exception as e:
        _log_warning(f"⚠️ Error in smart quote escaping: {e}")
        # Ultimate fallback: target the most common problematic patterns
        try:
            fixed = json_str
            
            # Common Python code patterns that cause issues
            patterns_to_fix = [
                (r'if __name__ == "__main__"', r'if __name__ == \"__main__\"'),
                (r'print\("([^"]*)"', r'print(\"\\1\"'),
                (r'input\("([^"]*)"', r'input(\"\\1\"'),
                (r'open\("([^"]*)"', r'open(\"\\1\"'),
                (r'== "__main__"', r'== \"__main__\"'),
                (r'!= "__main__"', r'!= \"__main__\"'),
            ]
            
            for pattern, replacement in patterns_to_fix:
                fixed = re.sub(pattern, replacement, fixed)
            
            return fixed
            
        except Exception:
            return json_str


def fix_json_string_values_robust(json_str: str) -> str:
    """
    使用字符级状态机修复JSON字符串值，更可靠地处理超长和复杂嵌套的字符串。
    
    特殊优化：对于tool_name/parameters格式的JSON，利用结尾的 }\n} 模式来
    更准确地判断字符串值的结束位置。
    
    这个函数使用逐字符解析的方式，比正则表达式更可靠，特别是对于：
    - 包含大量未转义换行符的长字符串
    - 包含XML/SVG代码的字符串
    - 包含引号、大括号等特殊字符的字符串
    
    Args:
        json_str: 可能包含未转义字符的JSON字符串
        
    Returns:
        修复后的JSON字符串
    """
    if not json_str:
        return json_str
    
    # 首先尝试直接解析，如果成功则无需修复
    try:
        json.loads(json_str)
        return json_str
    except json.JSONDecodeError as e:
        # 检查是否是控制字符错误（换行符等未转义）
        error_msg = str(e).lower()
        if 'control character' not in error_msg:
            # 如果不是控制字符错误，可能无法通过简单修复解决
            pass
        # 继续处理，尝试修复
    
    # 特殊优化：对于tool_name/parameters格式，先尝试直接修复code_edit字段
    # 利用结尾的 }\n} 模式来定位值结束位置
    # 策略：找到最后的}，然后在它之前找引号
    if '"code_edit": "' in json_str:
        code_edit_marker = '"code_edit": "'
        code_start = json_str.find(code_edit_marker) + len(code_edit_marker)
        
        # 找到最后的}（JSON对象结束）
        last_brace = json_str.rfind('}')
        if last_brace > code_start:
            # 在最后的}之前找引号（code_edit值的结束引号）
            quote_end_pos = json_str.rfind('"', code_start, last_brace)
            if quote_end_pos > code_start:
                value_content = json_str[code_start:quote_end_pos]
                # 转义控制字符，但要小心处理已经转义的字符
                # 策略：只转义未转义的控制字符
                fixed_value = []
                i = 0
                while i < len(value_content):
                    char = value_content[i]
                    if char == '\\' and i + 1 < len(value_content):
                        # 已经是转义字符，保留
                        fixed_value.append(char)
                        fixed_value.append(value_content[i+1])
                        i += 2
                    elif char == '"':
                        # 未转义的引号，需要转义
                        fixed_value.append('\\"')
                        i += 1
                    elif ord(char) < 32:  # 控制字符
                        # 转义控制字符
                        if char == '\n':
                            fixed_value.append('\\n')
                        elif char == '\r':
                            fixed_value.append('\\r')
                        elif char == '\t':
                            fixed_value.append('\\t')
                        elif char == '\b':
                            fixed_value.append('\\b')
                        elif char == '\f':
                            fixed_value.append('\\f')
                        else:
                            fixed_value.append(f'\\u{ord(char):04x}')
                        i += 1
                    else:
                        fixed_value.append(char)
                        i += 1
                
                fixed_value_str = ''.join(fixed_value)
                
                # 还需要转义未转义的引号
                # 但要小心：已经转义的引号（\"）不需要再转义
                # 简单策略：在字符串值中，所有未转义的引号都需要转义
                # 但我们已经转义了反斜杠，所以需要考虑
                # 更好的方法：在字符级处理时就已经处理了引号，这里只需要处理控制字符
                
                # 尝试解析修复后的JSON
                test_json = json_str[:code_start] + fixed_value_str + json_str[quote_end_pos:]
                try:
                    json.loads(test_json)
                    return test_json
                except json.JSONDecodeError as e:
                    # 如果还有引号问题，使用通用逻辑继续修复
                    # 但至少控制字符已经修复了
                    json_str = test_json  # 使用部分修复的JSON继续
                    pass  # 继续使用通用逻辑
    
    result = []
    i = 0
    in_string = False
    escape_next = False
    string_start_pos = -1
    
    while i < len(json_str):
        char = json_str[i]
        
        # 处理转义字符
        if escape_next:
            escape_next = False
            result.append(char)
            i += 1
            continue
        
        if char == '\\':
            escape_next = True
            result.append(char)
            i += 1
            continue
        
        # 处理字符串开始/结束
        if char == '"':
            if not in_string:
                # 字符串开始
                in_string = True
                string_start_pos = len(result)
                result.append(char)
            else:
                # 检查是否是字符串结束
                # 策略：向前查看最近的字符，向后查看后续字符
                # 如果前面是空白或标点，后面跟着逗号、右括号等，可能是字符串结束
                # 如果前后都是普通字符（中英文、数字），则是字符串内部的引号
                
                # 向前查看（跳过空白）
                prev_pos = i - 1
                while prev_pos >= 0 and json_str[prev_pos] in ' \t\n\r':
                    prev_pos -= 1
                prev_char = json_str[prev_pos] if prev_pos >= 0 else None
                
                # 向后查看（跳过空白）
                next_pos = i + 1
                while next_pos < len(json_str) and json_str[next_pos] in ' \t\n\r':
                    next_pos += 1
                next_char = json_str[next_pos] if next_pos < len(json_str) else None
                
                # 判断逻辑：
                # 1. 特殊优化：对于tool_name/parameters格式的JSON，结尾通常是 }\n}
                #    如果引号后面跟着 }\n} 模式，几乎肯定是字符串结束
                # 2. 如果后面是明确的结束标记（, } ]），且前面不是普通字符，则是字符串结束
                # 3. 如果后面跟着普通字符（字母、数字、中文等），则是字符串内部的引号
                # 4. 如果后面是引号，更可能是字符串内部的引号（需要转义）
                
                is_string_end = False
                
                # 特殊检查：看后面是否有 }\n} 或 "\n  }\n}" 模式（这是我们的JSON格式特征）
                # 对于tool_name/parameters格式，code_edit字段的值通常以 "\n  }\n}" 结尾
                remaining = json_str[i+1:]
                # 检查多种可能的结尾模式
                remaining_stripped = remaining.lstrip(' \t\n\r')
                # 模式1: 引号后直接是 }\n}
                if remaining_stripped.startswith('}\n}') or remaining_stripped.startswith('}\n  }'):
                    is_string_end = True
                # 模式2: 引号后是换行，然后是 }\n}
                elif remaining.startswith('\n  }\n}') or remaining.startswith('\n}\n}') or remaining.startswith(' \n  }\n}'):
                    is_string_end = True
                # 模式3: 检查是否是 "\n  }\n}" 完整模式（最典型的情况）
                elif i + 1 < len(json_str):
                    # 查看引号后面最多20个字符，看是否有 }\n} 模式
                    lookahead = json_str[i+1:min(i+21, len(json_str))]
                    # 查找 }\n} 或 }\n  } 模式
                    if ('}\n}' in lookahead or '}\n  }' in lookahead) and not ('"' in lookahead[:lookahead.find('}')]):
                        # 如果找到了结尾模式，且之间没有其他引号，说明这是字符串结束
                        is_string_end = True
                elif next_char is None:
                    # 到达末尾，字符串结束
                    is_string_end = True
                elif next_char in ',}]':
                    # 后面是结束标记，但需要更仔细地判断
                    # 如果前面是普通字符（字母、数字、中文等），说明这是字符串内部的引号
                    # 如果前面是空白、换行、引号等，可能是字符串结束
                    if prev_char:
                        # 检查前一个字符是否是普通文本字符
                        # 如果是中文字符、字母、数字等，说明引号在字符串内部
                        if (prev_char.isalnum() or 
                            '\u4e00' <= prev_char <= '\u9fff' or  # 中文字符范围
                            prev_char in '，。！？；：、'):
                            # 前面是普通字符，这是字符串内部的引号，需要转义
                            is_string_end = False
                        else:
                            # 前面是标点或空白，可能是字符串结束
                            is_string_end = True
                    else:
                        # 没有前一个字符，可能是字符串结束
                        is_string_end = True
                elif next_char == '"':
                    # 后面是引号，可能是 "key": "value"，但更可能是字符串内部的引号
                    is_string_end = False
                else:
                    # 后面跟着其他字符，肯定是字符串内部的引号
                    is_string_end = False
                
                if is_string_end:
                    in_string = False
                    result.append(char)
                else:
                    # 这是字符串内部的引号，需要转义
                    result.append('\\"')
            i += 1
            continue
        
        # 在字符串内部，转义特殊字符
        if in_string:
            # 转义所有控制字符（JSON不允许未转义的控制字符）
            if char == '\n':
                result.append('\\n')
            elif char == '\t':
                result.append('\\t')
            elif char == '\r':
                result.append('\\r')
            elif char == '\b':
                result.append('\\b')
            elif char == '\f':
                result.append('\\f')
            elif ord(char) < 32:  # 所有控制字符（ASCII < 32）都需要转义
                # JSON中控制字符必须转义为 \uXXXX 格式
                result.append(f'\\u{ord(char):04x}')
            else:
                result.append(char)
        else:
            # 不在字符串中，保持原样
            result.append(char)
        
        i += 1
    
    fixed_json = ''.join(result)
    
    # 验证修复后的JSON是否有效
    try:
        json.loads(fixed_json)
        return fixed_json
    except json.JSONDecodeError:
        # 如果修复后仍然无效，返回原字符串让其他方法处理
        return json_str


def rebuild_json_structure(json_str: str) -> str:
    """
    Last resort method to rebuild JSON structure from malformed JSON.
    
    Args:
        json_str: Malformed JSON string
        
    Returns:
        Rebuilt JSON string
    """
    # Try to extract key-value pairs and rebuild the JSON
    # This is a very basic approach for specific cases
    
    # Look for pattern: "key": "value" or "key": value
    pairs = []
    
    # Extract string values
    string_pattern = r'"([^"]+)":\s*"([^"]*(?:\\.[^"]*)*)"'
    for match in re.finditer(string_pattern, json_str, re.DOTALL):
        key = match.group(1)
        value = match.group(2)
        # Escape the value properly
        value = value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r')
        pairs.append(f'"{key}": "{value}"')
    
    # Extract non-string values (numbers, booleans, null)
    non_string_pattern = r'"([^"]+)":\s*([^",}\s]+)'
    for match in re.finditer(non_string_pattern, json_str):
        key = match.group(1)
        value = match.group(2).strip()
        # Skip if this was already captured as a string
        if not any(f'"{key}":' in pair for pair in pairs):
            pairs.append(f'"{key}": {value}')
    
    if pairs:
        rebuilt_json = '{' + ', '.join(pairs) + '}'
        try:
            # Validate the rebuilt JSON
            json.loads(rebuilt_json)
            return rebuilt_json
        except json.JSONDecodeError:
            pass
    
    # If rebuild failed, return original
    return json_str


def parse_python_params_manually(params_str: str) -> Dict[str, Any]:
    """
    Manually parse Python function parameters when JSON parsing fails.
    
    Args:
        params_str: Parameter string from Python function call
        
    Returns:
        Dictionary of parameters
    """
    params = {}
    
    # Remove the outer braces if present
    if params_str.startswith('{') and params_str.endswith('}'):
        params_str = params_str[1:-1].strip()
    
    # Split by commas, but be careful about commas inside strings
    param_parts = []
    current_part = ""
    in_quotes = False
    quote_char = None
    brace_depth = 0
    
    for char in params_str:
        if char in ('"', "'") and not in_quotes:
            in_quotes = True
            quote_char = char
            current_part += char
        elif char == quote_char and in_quotes:
            in_quotes = False
            quote_char = None
            current_part += char
        elif char == '{' and not in_quotes:
            brace_depth += 1
            current_part += char
        elif char == '}' and not in_quotes:
            brace_depth -= 1
            current_part += char
        elif char == ',' and not in_quotes and brace_depth == 0:
            param_parts.append(current_part.strip())
            current_part = ""
        else:
            current_part += char
    
    if current_part.strip():
        param_parts.append(current_part.strip())
    
    # Parse each parameter
    for part in param_parts:
        # Look for key: value pattern
        if ':' in part:
            key_value = part.split(':', 1)
            if len(key_value) == 2:
                key = key_value[0].strip().strip('"\'')
                value = key_value[1].strip()
                
                # Remove quotes from value if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                # Convert boolean values
                if value.lower() in ('true', 'false'):
                    value = value.lower() == 'true'
                # Convert numeric values
                elif value.isdigit():
                    value = int(value)
                
                params[key] = value
    
    return params


def convert_parameter_value(value: str) -> Any:
    """
    Convert parameter value to appropriate type.
    
    Args:
        value: String value to convert
        
    Returns:
        Converted value (string, int, bool, list, etc.)
    """
    # For certain parameters that may contain meaningful whitespace/formatting,
    # don't strip the value
    value_stripped = value.strip()
    
    # Handle boolean values
    if value_stripped.lower() in ('true', 'false'):
        return value_stripped.lower() == 'true'
    
    # Handle integers
    if value_stripped.isdigit():
        return int(value_stripped)
    
    # Handle negative integers
    if value_stripped.startswith('-') and value_stripped[1:].isdigit():
        return int(value_stripped)
    
    # Handle JSON arrays/objects
    if (value_stripped.startswith('[') and value_stripped.endswith(']')) or (value_stripped.startswith('{') and value_stripped.endswith('}')):
        try:
            return json.loads(value_stripped)
        except json.JSONDecodeError:
            pass
    
    # Return original value (not stripped) for string parameters to preserve formatting
    return value


def generate_tools_prompt_from_json(tool_definitions: Dict[str, Any], language: str = 'en') -> str:
    """
    Generate tools prompt string from JSON tool definitions for chat-based models.
    
    Args:
        tool_definitions: Dictionary of tool definitions loaded from JSON
        language: Language code ('zh' for Chinese, 'en' for English)
        
    Returns:
        Formatted string containing tool descriptions for chat-based models
    """
    try:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
        
        if not tool_definitions:
            return ""
        
        prompt_parts = []
        
        # Add header
        if language == 'zh':
            prompt_parts.append("## Available tools")
            prompt_parts.append("")
            prompt_parts.append("You can use the following tools to complete tasks. Please use JSON format to call tools:")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "Tool name",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "Parameter name": "Parameter value"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### Tool list:")
        else:
            prompt_parts.append("## Available Tools")
            prompt_parts.append("")
            prompt_parts.append("You can use the following tools to complete tasks. Please call tools using JSON format:")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "tool_name",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "param_name": "param_value"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### Tool List:")
        
        prompt_parts.append("")
        
        # Add each tool's description
        for tool_name, tool_def in sorted(tool_definitions.items()):
            description = tool_def.get('description', 'No description available')
            parameters = tool_def.get('parameters', {})
            properties = parameters.get('properties', {})
            required = parameters.get('required', [])
            
            # Tool header
            prompt_parts.append(f"#### {tool_name}")
            prompt_parts.append(f"**Description**: {description}" if language == 'zh' else f"**Description**: {description}")
            prompt_parts.append("")
            
            # Parameters
            if properties:
                prompt_parts.append("**Parameters**:" if language == 'zh' else "**Parameters**:")
                for param_name, param_def in properties.items():
                    param_type = param_def.get('type', 'string')
                    param_desc = param_def.get('description', 'No description')
                    param_required = param_name in required
                    required_marker = " (Required)" if language == 'zh' else " (required)" if param_required else ""
                    
                    # Handle array type
                    if param_type == 'array':
                        items_type = param_def.get('items', {}).get('type', 'string')
                        param_type = f"array[{items_type}]"
                    
                    prompt_parts.append(f"- `{param_name}` ({param_type}){required_marker}: {param_desc}")
                
                prompt_parts.append("")
            else:
                prompt_parts.append("**Parameters**: None" if language == 'zh' else "**Parameters**: None")
                prompt_parts.append("")
            
            # Example usage
            if language == 'zh':
                prompt_parts.append("**Usage Example**:")
            else:
                prompt_parts.append("**Example Usage**:")
            
            # Generate example based on tool
            example_params = {}
            for param_name, param_def in properties.items():
                if param_name in required:
                    param_type = param_def.get('type', 'string')
                    if param_type == 'string':
                        example_params[param_name] = "example_value"
                    elif param_type == 'integer':
                        example_params[param_name] = 1
                    elif param_type == 'boolean':
                        example_params[param_name] = True
                    elif param_type == 'array':
                        example_params[param_name] = ["item1", "item2"]
                    elif param_type == 'object':
                        example_params[param_name] = {"key": "value"}
            
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append(f'  "tool_name": "{tool_name}",')
            prompt_parts.append('  "parameters": {')
            
            if example_params:
                param_lines = []
                for key, value in example_params.items():
                    if isinstance(value, str):
                        param_lines.append(f'    "{key}": "{value}"')
                    else:
                        import json
                        param_lines.append(f'    "{key}": {json.dumps(value)}')
                prompt_parts.append(',\n'.join(param_lines))
            
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("---")
            prompt_parts.append("")
        
        # Add footer instructions
        if language == 'zh':
            prompt_parts.append("### Important notes:")
            prompt_parts.append("1. Please strictly follow the above JSON format to call tools")
            prompt_parts.append("2. Tool name must match exactly")
            prompt_parts.append("3. Required parameters cannot be omitted")
            prompt_parts.append("4. Parameter types must be correct")
            prompt_parts.append("5. Multiple tools can be called simultaneously")
        else:
            prompt_parts.append("### Important Notes:")
            prompt_parts.append("1. Please strictly follow the JSON format above for tool calls")
            prompt_parts.append("2. Tool names must match exactly")
            prompt_parts.append("3. Required parameters cannot be omitted")
            prompt_parts.append("4. Parameter types must be correct")
            prompt_parts.append("5. Multiple tools can be called simultaneously")
        
        return "\n".join(prompt_parts)
        
    except Exception as e:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
                
        print_current(f"⚠️  Error generating tools prompt from JSON: {e}")
        return ""


# Convenience function aliases for backward compatibility
_fix_json_escapes = fix_json_escapes
_smart_escape_quotes_in_json_values = smart_escape_quotes_in_json_values  
_rebuild_json_structure = rebuild_json_structure
_parse_python_params_manually = parse_python_params_manually
_convert_parameter_value = convert_parameter_value 