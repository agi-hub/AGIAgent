#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
JSON parsing and fixing utilities.

This module contains utility functions for parsing and fixing malformed JSON strings,
particularly those generated by language models that may contain escape issues or
structural problems.

Migrated from tool_executor.py for better code organization and reusability.
"""

import json
import re
from typing import Dict, Any, Optional


def _log_warning(message: str) -> None:
    """
    Simple logging function to replace print_current dependency.
    
    Args:
        message: Warning message to log
    """
    try:
        # Try to import print_current if available
        from tools.print_system import print_current
        print_current(message)
    except ImportError:
        # Fallback to standard print if print_current is not available
        print(message)


def fix_json_escapes(json_str: str) -> str:
    """
    Simplified JSON escape function - just returns the original string.
    Complex regex processing has been removed to avoid catastrophic backtracking.
    
    Args:
        json_str: Raw JSON string
        
    Returns:
        Original JSON string (no processing)
    """
    return json_str


def smart_escape_quotes_in_json_values(json_str: str) -> str:
    """
    Smart method to escape unescaped quotes in JSON values while preserving JSON structure.
    
    优化版本：对于超长文本（>5000字符），直接使用更可靠的字符级状态机方法。
    对于短文本，使用正则表达式快速修复。
    
    Args:
        json_str: Raw JSON string that may have unescaped quotes in values
        
    Returns:
        JSON string with properly escaped quotes in values
    """
    # 对于超长文本，直接使用更可靠的方法
    if len(json_str) > 5000:
        return fix_json_string_values_robust(json_str)
    
    try:
        # 对于短文本，使用优化的正则表达式方法
        def escape_value_content(content: str) -> str:
            """
            转义字符串值中的未转义字符。
            使用字符级处理，避免正则表达式在长文本时的性能问题。
            """
            result = []
            i = 0
            escape_count = 0
            
            while i < len(content):
                char = content[i]
                
                # 统计连续的反斜杠
                if char == '\\':
                    j = i
                    while j < len(content) and content[j] == '\\':
                        j += 1
                    escape_count = j - i
                    
                    # 如果前面有奇数个反斜杠，当前反斜杠是转义序列的一部分
                    if escape_count % 2 == 1:
                        result.append(char)
                        i += 1
                        continue
                    else:
                        # 偶数个反斜杠，这些反斜杠都是字面量
                        result.append('\\\\' * (escape_count // 2))
                        i = j
                        continue
                
                # 重置转义计数
                escape_count = 0
                
                # 转义未转义的引号
                if char == '"':
                    # 检查前面是否有转义
                    prev_pos = i - 1
                    backslash_count = 0
                    while prev_pos >= 0 and content[prev_pos] == '\\':
                        backslash_count += 1
                        prev_pos -= 1
                    
                    if backslash_count % 2 == 0:
                        # 未转义的引号，需要转义
                        result.append('\\"')
                    else:
                        result.append(char)
                elif ord(char) < 32:  # 控制字符
                    # 检查前面是否有转义
                    prev_pos = i - 1
                    backslash_count = 0
                    while prev_pos >= 0 and content[prev_pos] == '\\':
                        backslash_count += 1
                        prev_pos -= 1
                    
                    if backslash_count % 2 == 0:
                        # 未转义的控制字符，需要转义
                        if char == '\n':
                            result.append('\\n')
                        elif char == '\r':
                            result.append('\\r')
                        elif char == '\t':
                            result.append('\\t')
                        elif char == '\b':
                            result.append('\\b')
                        elif char == '\f':
                            result.append('\\f')
                        else:
                            result.append(f'\\u{ord(char):04x}')
                    else:
                        result.append(char)
                else:
                    result.append(char)
                
                i += 1
            
            return ''.join(result)
        
        # 改进的模式：匹配 "field": "value" 格式
        # 使用更精确的结束标记检测
        pattern = r'("[^"]*"\s*:\s*")(.*?)(?="\s*[,}\n])'
        
        def escape_value_quotes(match):
            prefix = match.group(1)  # "field": "
            content = match.group(2)  # content that may contain quotes, newlines, etc.
            
            # 使用字符级处理转义
            escaped_content = escape_value_content(content)
            
            return f'{prefix}{escaped_content}"'
        
        fixed_json = re.sub(pattern, escape_value_quotes, json_str, flags=re.DOTALL)
        
        # 如果正则表达式方法没有修复，尝试使用字符级状态机方法
        if fixed_json == json_str:
            return fix_json_string_values_robust(json_str)
        
        # 验证修复后的JSON是否有效
        try:
            json.loads(fixed_json)
            return fixed_json
        except json.JSONDecodeError:
            # 如果修复后仍然无效，使用更可靠的方法
            return fix_json_string_values_robust(json_str)
        
    except Exception as e:
        _log_warning(f"⚠️ Error in smart quote escaping: {e}")
        # 如果出错，回退到更可靠的方法
        return fix_json_string_values_robust(json_str)


def fix_json_string_values_robust(json_str: str) -> str:
    """
    使用字符级状态机修复JSON字符串值，更可靠地处理超长和复杂嵌套的字符串。
    
    优化版本：改进了转义字符处理逻辑，特别是对\n等控制字符的转义。
    使用更可靠的字符串边界检测算法，能够正确处理超长文本。
    
    这个函数使用逐字符解析的方式，比正则表达式更可靠，特别是对于：
    - 包含大量未转义换行符的长字符串
    - 包含XML/SVG代码的字符串
    - 包含引号、大括号等特殊字符的字符串
    
    Args:
        json_str: 可能包含未转义字符的JSON字符串
        
    Returns:
        修复后的JSON字符串
    """
    if not json_str:
        return json_str
    
    # 首先尝试直接解析，如果成功则无需修复
    try:
        json.loads(json_str)
        return json_str
    except json.JSONDecodeError:
        # 继续处理，尝试修复
        pass
    
    # 使用字符级状态机进行修复
    result = []
    i = 0
    in_string = False
    next_char_escaped = False  # 标志：下一个字符是否被转义
    brace_depth = 0  # 大括号嵌套深度，用于辅助判断字符串边界
    bracket_depth = 0  # 方括号嵌套深度
    
    while i < len(json_str):
        char = json_str[i]
        
        # 处理转义序列
        if next_char_escaped:
            # 当前字符被转义，直接添加到结果中
            result.append(char)
            next_char_escaped = False
            i += 1
            continue
        
        # 统计连续的反斜杠
        if char == '\\':
            j = i
            while j < len(json_str) and json_str[j] == '\\':
                j += 1
            backslash_count = j - i
            
            # 如果不在字符串中，反斜杠应该被保留（可能是JSON结构的一部分）
            if not in_string:
                result.append(char)
                i += 1
                continue
            
            # 在字符串中，需要判断这是转义序列还是字面量反斜杠
            if backslash_count % 2 == 1:
                # 奇数个反斜杠，下一个字符会被转义
                result.append(char)
                next_char_escaped = True  # 标记下一个字符被转义
                i += 1
                continue
            else:
                # 偶数个反斜杠，这些反斜杠都是字面量
                result.append('\\\\' * (backslash_count // 2))
                i = j
                continue
        
        # 处理字符串开始/结束
        if char == '"':
            if not in_string:
                # 字符串开始
                in_string = True
                result.append(char)
            else:
                # 检查是否是字符串结束
                # 关键改进：使用更可靠的算法判断字符串边界
                is_string_end = _is_string_end(json_str, i, brace_depth, bracket_depth)
                
                if is_string_end:
                    in_string = False
                    result.append(char)
                else:
                    # 这是字符串内部的引号，需要转义
                    result.append('\\"')
            i += 1
            continue
        
        # 更新嵌套深度（不在字符串中时）
        if not in_string:
            if char == '{':
                brace_depth += 1
            elif char == '}':
                brace_depth -= 1
            elif char == '[':
                bracket_depth += 1
            elif char == ']':
                bracket_depth -= 1
        
        # 在字符串内部，转义控制字符和特殊字符
        if in_string:
            # 转义所有控制字符（JSON不允许未转义的控制字符）
            # 关键改进：如果 next_char_escaped 为 True，说明字符已经被转义，不需要再次转义
            if ord(char) < 32:  # 控制字符
                # 如果字符已经被转义（通过转义序列），直接添加
                # 注意：next_char_escaped 标志已经在上面处理了，所以这里不会遇到已转义的字符
                # 未转义的控制字符，需要转义
                if char == '\n':
                    result.append('\\n')
                elif char == '\r':
                    result.append('\\r')
                elif char == '\t':
                    result.append('\\t')
                elif char == '\b':
                    result.append('\\b')
                elif char == '\f':
                    result.append('\\f')
                else:
                    result.append(f'\\u{ord(char):04x}')
            else:
                result.append(char)
        else:
            # 不在字符串中，保持原样
            result.append(char)
        
        i += 1
    
    fixed_json = ''.join(result)
    
    # 验证修复后的JSON是否有效
    try:
        json.loads(fixed_json)
        return fixed_json
    except json.JSONDecodeError:
        # 如果修复后仍然无效，返回原字符串让其他方法处理
        return json_str


def _is_string_end(json_str: str, quote_pos: int, brace_depth: int, bracket_depth: int) -> bool:
    """
    判断引号是否是字符串结束引号。
    
    使用多种策略来判断：
    1. 检查引号后面的内容是否符合JSON结构
    2. 检查大括号和方括号的嵌套深度
    3. 检查是否有明确的结束标记（逗号、右括号等）
    
    Args:
        json_str: JSON字符串
        quote_pos: 引号的位置
        brace_depth: 当前大括号嵌套深度
        bracket_depth: 当前方括号嵌套深度
        
    Returns:
        True如果这是字符串结束引号，False如果是字符串内部的引号
    """
    if quote_pos + 1 >= len(json_str):
        # 到达末尾，肯定是字符串结束
        return True
    
    # 跳过引号后的空白字符
    next_pos = quote_pos + 1
    while next_pos < len(json_str) and json_str[next_pos] in ' \t\n\r':
        next_pos += 1
    
    if next_pos >= len(json_str):
        return True
    
    next_char = json_str[next_pos]
    
    # 如果后面是明确的结束标记，很可能是字符串结束
    if next_char in ',}':
        # 检查前面是否有未闭合的结构
        # 如果大括号深度为0或1，且后面是}，很可能是字符串结束
        if next_char == '}' and brace_depth <= 1:
            return True
        if next_char == ',':
            return True
    
    # 关键修复：如果后面是冒号，说明这是键名的结束引号
    if next_char == ':':
        return True
    
    # 检查后面是否有 }\n} 或 }\n  } 模式（tool_name/parameters格式的特征）
    remaining = json_str[quote_pos + 1:]
    remaining_stripped = remaining.lstrip(' \t\n\r')
    
    if remaining_stripped.startswith('}\n}') or remaining_stripped.startswith('}\n  }'):
        return True
    
    # 对于超长内容，扩大查找范围
    if len(json_str) > 1000:
        lookahead_size = min(200, len(json_str) - quote_pos - 1)
        lookahead = json_str[quote_pos + 1:quote_pos + 1 + lookahead_size]
        
        # 查找 }\n} 或 }\n  } 模式
        if '}\n}' in lookahead or '}\n  }' in lookahead:
            # 找到第一个}的位置
            first_brace_pos = lookahead.find('}')
            if first_brace_pos > 0:
                # 检查在}之前是否有其他未转义的引号
                before_brace = lookahead[:first_brace_pos]
                # 简单检查：如果引号数量是偶数，说明没有未闭合的字符串
                quote_count = before_brace.count('"')
                # 粗略估计：如果引号数量很少，可能是字符串结束
                if quote_count <= 2:
                    return True
    
    # 如果后面跟着普通字符（字母、数字、中文等），可能是字符串内部的引号
    if next_char.isalnum() or '\u4e00' <= next_char <= '\u9fff':
        return False
    
    # 如果后面是引号，可能是 "key": "value" 格式，但也可能是字符串内部的引号
    # 保守策略：假设是字符串内部的引号
    if next_char == '"':
        return False
    
    # 默认情况：如果后面是结束标记，认为是字符串结束
    return next_char in ',}]'


def rebuild_json_structure(json_str: str) -> str:
    """
    Last resort method to rebuild JSON structure from malformed JSON.
    
    Args:
        json_str: Malformed JSON string
        
    Returns:
        Rebuilt JSON string
    """
    # Try to extract key-value pairs and rebuild the JSON
    # This is a very basic approach for specific cases
    
    # Look for pattern: "key": "value" or "key": value
    pairs = []
    
    # Extract string values
    string_pattern = r'"([^"]+)":\s*"([^"]*(?:\\.[^"]*)*)"'
    for match in re.finditer(string_pattern, json_str, re.DOTALL):
        key = match.group(1)
        value = match.group(2)
        # Escape the value properly
        value = value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r')
        pairs.append(f'"{key}": "{value}"')
    
    # Extract non-string values (numbers, booleans, null)
    non_string_pattern = r'"([^"]+)":\s*([^",}\s]+)'
    for match in re.finditer(non_string_pattern, json_str):
        key = match.group(1)
        value = match.group(2).strip()
        # Skip if this was already captured as a string
        if not any(f'"{key}":' in pair for pair in pairs):
            pairs.append(f'"{key}": {value}')
    
    if pairs:
        rebuilt_json = '{' + ', '.join(pairs) + '}'
        try:
            # Validate the rebuilt JSON
            json.loads(rebuilt_json)
            return rebuilt_json
        except json.JSONDecodeError:
            pass
    
    # If rebuild failed, return original
    return json_str


def parse_python_params_manually(params_str: str) -> Dict[str, Any]:
    """
    Manually parse Python function parameters when JSON parsing fails.
    
    Args:
        params_str: Parameter string from Python function call
        
    Returns:
        Dictionary of parameters
    """
    params = {}
    
    # Remove the outer braces if present
    if params_str.startswith('{') and params_str.endswith('}'):
        params_str = params_str[1:-1].strip()
    
    # Split by commas, but be careful about commas inside strings
    param_parts = []
    current_part = ""
    in_quotes = False
    quote_char = None
    brace_depth = 0
    
    for char in params_str:
        if char in ('"', "'") and not in_quotes:
            in_quotes = True
            quote_char = char
            current_part += char
        elif char == quote_char and in_quotes:
            in_quotes = False
            quote_char = None
            current_part += char
        elif char == '{' and not in_quotes:
            brace_depth += 1
            current_part += char
        elif char == '}' and not in_quotes:
            brace_depth -= 1
            current_part += char
        elif char == ',' and not in_quotes and brace_depth == 0:
            param_parts.append(current_part.strip())
            current_part = ""
        else:
            current_part += char
    
    if current_part.strip():
        param_parts.append(current_part.strip())
    
    # Parse each parameter
    for part in param_parts:
        # Look for key: value pattern
        if ':' in part:
            key_value = part.split(':', 1)
            if len(key_value) == 2:
                key = key_value[0].strip().strip('"\'')
                value = key_value[1].strip()
                
                # Remove quotes from value if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                # Convert boolean values
                if value.lower() in ('true', 'false'):
                    value = value.lower() == 'true'
                # Convert numeric values
                elif value.isdigit():
                    value = int(value)
                
                params[key] = value
    
    return params


def convert_parameter_value(value: str) -> Any:
    """
    Convert parameter value to appropriate type.
    
    Args:
        value: String value to convert
        
    Returns:
        Converted value (string, int, bool, list, etc.)
    """
    # For certain parameters that may contain meaningful whitespace/formatting,
    # don't strip the value
    value_stripped = value.strip()
    
    # Handle boolean values
    if value_stripped.lower() in ('true', 'false'):
        return value_stripped.lower() == 'true'
    
    # Handle integers
    if value_stripped.isdigit():
        return int(value_stripped)
    
    # Handle negative integers
    if value_stripped.startswith('-') and value_stripped[1:].isdigit():
        return int(value_stripped)
    
    # Handle JSON arrays/objects
    if (value_stripped.startswith('[') and value_stripped.endswith(']')) or (value_stripped.startswith('{') and value_stripped.endswith('}')):
        try:
            return json.loads(value_stripped)
        except json.JSONDecodeError:
            pass
    
    # Return original value (not stripped) for string parameters to preserve formatting
    return value


def generate_tools_prompt_from_json(tool_definitions: Dict[str, Any], language: str = 'en') -> str:
    """
    Generate tools prompt string from JSON tool definitions for chat-based models.
    
    Args:
        tool_definitions: Dictionary of tool definitions loaded from JSON
        language: Language code ('zh' for Chinese, 'en' for English)
        
    Returns:
        Formatted string containing tool descriptions for chat-based models
    """
    try:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
        
        if not tool_definitions:
            return ""
        
        prompt_parts = []
        
        # Add header
        if language == 'zh':
            prompt_parts.append("## Available tools")
            prompt_parts.append("")
            prompt_parts.append("You can use the following tools to complete tasks. Please use JSON format to call tools:")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "Tool name",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "Parameter name": "Parameter value"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### Tool list:")
        else:
            prompt_parts.append("## Available Tools")
            prompt_parts.append("")
            prompt_parts.append("You can use the following tools to complete tasks. Please call tools using JSON format:")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "tool_name",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "param_name": "param_value"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### Tool List:")
        
        prompt_parts.append("")
        
        # Add each tool's description
        for tool_name, tool_def in sorted(tool_definitions.items()):
            description = tool_def.get('description', 'No description available')
            parameters = tool_def.get('parameters', {})
            properties = parameters.get('properties', {})
            required = parameters.get('required', [])
            
            # Tool header
            prompt_parts.append(f"#### {tool_name}")
            prompt_parts.append(f"**Description**: {description}" if language == 'zh' else f"**Description**: {description}")
            prompt_parts.append("")
            
            # Parameters
            if properties:
                prompt_parts.append("**Parameters**:" if language == 'zh' else "**Parameters**:")
                for param_name, param_def in properties.items():
                    param_type = param_def.get('type', 'string')
                    param_desc = param_def.get('description', 'No description')
                    param_required = param_name in required
                    required_marker = " (Required)" if language == 'zh' else " (required)" if param_required else ""
                    
                    # Handle array type
                    if param_type == 'array':
                        items_type = param_def.get('items', {}).get('type', 'string')
                        param_type = f"array[{items_type}]"
                    
                    prompt_parts.append(f"- `{param_name}` ({param_type}){required_marker}: {param_desc}")
                
                prompt_parts.append("")
            else:
                prompt_parts.append("**Parameters**: None" if language == 'zh' else "**Parameters**: None")
                prompt_parts.append("")
            
            # Example usage
            if language == 'zh':
                prompt_parts.append("**Usage Example**:")
            else:
                prompt_parts.append("**Example Usage**:")
            
            # Generate example based on tool
            example_params = {}
            for param_name, param_def in properties.items():
                if param_name in required:
                    param_type = param_def.get('type', 'string')
                    if param_type == 'string':
                        example_params[param_name] = "example_value"
                    elif param_type == 'integer':
                        example_params[param_name] = 1
                    elif param_type == 'boolean':
                        example_params[param_name] = True
                    elif param_type == 'array':
                        example_params[param_name] = ["item1", "item2"]
                    elif param_type == 'object':
                        example_params[param_name] = {"key": "value"}
            
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append(f'  "tool_name": "{tool_name}",')
            prompt_parts.append('  "parameters": {')
            
            if example_params:
                param_lines = []
                for key, value in example_params.items():
                    if isinstance(value, str):
                        param_lines.append(f'    "{key}": "{value}"')
                    else:
                        import json
                        param_lines.append(f'    "{key}": {json.dumps(value)}')
                prompt_parts.append(',\n'.join(param_lines))
            
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("---")
            prompt_parts.append("")
        
        # Add footer instructions
        if language == 'zh':
            prompt_parts.append("### Important notes:")
            prompt_parts.append("1. Please strictly follow the above JSON format to call tools")
            prompt_parts.append("2. Tool name must match exactly")
            prompt_parts.append("3. Required parameters cannot be omitted")
            prompt_parts.append("4. Parameter types must be correct")
            prompt_parts.append("5. Multiple tools can be called simultaneously")
        else:
            prompt_parts.append("### Important Notes:")
            prompt_parts.append("1. Please strictly follow the JSON format above for tool calls")
            prompt_parts.append("2. Tool names must match exactly")
            prompt_parts.append("3. Required parameters cannot be omitted")
            prompt_parts.append("4. Parameter types must be correct")
            prompt_parts.append("5. Multiple tools can be called simultaneously")
        
        return "\n".join(prompt_parts)
        
    except Exception as e:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
                
        print_current(f"⚠️  Error generating tools prompt from JSON: {e}")
        return ""


# Convenience function aliases for backward compatibility
_fix_json_escapes = fix_json_escapes
_smart_escape_quotes_in_json_values = smart_escape_quotes_in_json_values  
_rebuild_json_structure = rebuild_json_structure
_parse_python_params_manually = parse_python_params_manually
_convert_parameter_value = convert_parameter_value 