#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
JSON parsing and fixing utilities.

This module contains utility functions for parsing and fixing malformed JSON strings,
particularly those generated by language models that may contain escape issues or
structural problems.

Migrated from tool_executor.py for better code organization and reusability.
"""

import json
import re
from typing import Dict, Any, Optional


def _log_warning(message: str) -> None:
    """
    Simple logging function to replace print_current dependency.
    
    Args:
        message: Warning message to log
    """
    try:
        # Try to import print_current if available
        from tools.print_system import print_current
        print_current(message)
    except ImportError:
        # Fallback to standard print if print_current is not available
        print(message)


def fix_json_escapes(json_str: str) -> str:
    """
    Simplified JSON escape function - just returns the original string.
    Complex regex processing has been removed to avoid catastrophic backtracking.
    
    Args:
        json_str: Raw JSON string
        
    Returns:
        Original JSON string (no processing)
    """
    return json_str


def smart_escape_quotes_in_json_values(json_str: str) -> str:
    """
    Smart method to escape unescaped quotes in JSON values while preserving JSON structure.
    
    This method uses a simple but effective approach: find JSON values and escape quotes within them.
    
    Args:
        json_str: Raw JSON string that may have unescaped quotes in values
        
    Returns:
        JSON string with properly escaped quotes in values
    """
    try:
        # More robust approach: find JSON string values and escape unescaped characters
        # This handles multiline strings with unescaped newlines, quotes, etc.
        
        def escape_value_quotes(match):
            prefix = match.group(1)  # "field": "
            content = match.group(2)  # content that may contain quotes, newlines, etc.
            
            # Escape unescaped quotes in the content
            escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
            
            # Also escape other common problematic characters (newlines, tabs, carriage returns)
            escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
            escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
            escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
            
            return f'{prefix}{escaped_content}"'
        
        # Improved pattern: matches "field": "value" where value can contain newlines
        # Uses non-greedy matching with DOTALL flag to handle multiline strings
        # The pattern looks for: "field": "content" where content may span multiple lines
        pattern = r'("[^"]*"\s*:\s*")(.*?)(?="\s*[,}])'
        
        fixed_json = re.sub(pattern, escape_value_quotes, json_str, flags=re.DOTALL)
        
        # Handle edge case: if the pattern didn't match properly, try a different approach
        if fixed_json == json_str:
            # Alternative approach: specifically target code_edit field which commonly has this issue
            # This handles SVG XML content and other complex content with multiline strings
            code_edit_pattern = r'("code_edit"\s*:\s*")(.*?)(?="\s*[,}])'
            def fix_code_edit_quotes(match):
                prefix = match.group(1)
                content = match.group(2)
                # Escape unescaped quotes, but preserve SVG/XML structure
                escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
                # Also escape newlines and tabs for JSON compatibility
                escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                return f'{prefix}{escaped_content}"'
            
            fixed_json = re.sub(code_edit_pattern, fix_code_edit_quotes, json_str, flags=re.DOTALL)
            
            # If still not fixed, try handling any field that contains XML-like content
            if fixed_json == json_str:
                # Pattern to match any field value that contains XML/SVG tags
                xml_content_pattern = r'("[\w_]+"\s*:\s*")(.*?<svg.*?>.*?)(?="\s*[,}])'
                def fix_xml_content_quotes(match):
                    prefix = match.group(1)
                    content = match.group(2)
                    # Escape unescaped quotes in XML content
                    escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
                    escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                    escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                    escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                    return f'{prefix}{escaped_content}"'
                
                fixed_json = re.sub(xml_content_pattern, fix_xml_content_quotes, json_str, flags=re.DOTALL)
        
        # If still not fixed, try a more aggressive approach: find unescaped newlines in string values
        # This handles cases where the string doesn't have a proper closing quote
        if fixed_json == json_str:
            # Look for patterns like "field": "value with\nnewline" where the newline is not escaped
            # and try to escape it
            lines = json_str.split('\n')
            fixed_lines = []
            in_string_value = False
            string_start_key = None
            
            for i, line in enumerate(lines):
                # Check if this line starts a string value
                string_value_match = re.match(r'(\s*"[^"]*"\s*:\s*")(.*)', line)
                if string_value_match:
                    in_string_value = True
                    string_start_key = string_value_match.group(1)
                    content = string_value_match.group(2)
                    # Check if the line ends with a closing quote
                    if re.search(r'"\s*[,}]', line):
                        # String ends on this line
                        escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
                        escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                        fixed_lines.append(f'{string_start_key}{escaped_content}')
                        in_string_value = False
                        string_start_key = None
                    else:
                        # String continues on next line(s)
                        fixed_lines.append(line)
                elif in_string_value:
                    # This line is part of a multiline string value
                    # Check if this line ends the string
                    if re.search(r'"\s*[,}]', line):
                        # String ends on this line
                        escaped_content = re.sub(r'(?<!\\)"', '\\"', line)
                        escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
                        escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
                        fixed_lines.append(escaped_content.replace('\n', '\\n'))
                        in_string_value = False
                        string_start_key = None
                    else:
                        # Still in the string value, escape the line
                        escaped_line = line.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r')
                        fixed_lines.append(escaped_line)
                else:
                    fixed_lines.append(line)
            
            if fixed_lines != lines:
                fixed_json = '\n'.join(fixed_lines)
        
        return fixed_json
        
    except Exception as e:
        _log_warning(f"⚠️ Error in smart quote escaping: {e}")
        # Ultimate fallback: target the most common problematic patterns
        try:
            fixed = json_str
            
            # Common Python code patterns that cause issues
            patterns_to_fix = [
                (r'if __name__ == "__main__"', r'if __name__ == \"__main__\"'),
                (r'print\("([^"]*)"', r'print(\"\\1\"'),
                (r'input\("([^"]*)"', r'input(\"\\1\"'),
                (r'open\("([^"]*)"', r'open(\"\\1\"'),
                (r'== "__main__"', r'== \"__main__\"'),
                (r'!= "__main__"', r'!= \"__main__\"'),
            ]
            
            for pattern, replacement in patterns_to_fix:
                fixed = re.sub(pattern, replacement, fixed)
            
            return fixed
            
        except Exception:
            return json_str


def rebuild_json_structure(json_str: str) -> str:
    """
    Last resort method to rebuild JSON structure from malformed JSON.
    
    Args:
        json_str: Malformed JSON string
        
    Returns:
        Rebuilt JSON string
    """
    # Try to extract key-value pairs and rebuild the JSON
    # This is a very basic approach for specific cases
    
    # Look for pattern: "key": "value" or "key": value
    pairs = []
    
    # Extract string values
    string_pattern = r'"([^"]+)":\s*"([^"]*(?:\\.[^"]*)*)"'
    for match in re.finditer(string_pattern, json_str, re.DOTALL):
        key = match.group(1)
        value = match.group(2)
        # Escape the value properly
        value = value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r')
        pairs.append(f'"{key}": "{value}"')
    
    # Extract non-string values (numbers, booleans, null)
    non_string_pattern = r'"([^"]+)":\s*([^",}\s]+)'
    for match in re.finditer(non_string_pattern, json_str):
        key = match.group(1)
        value = match.group(2).strip()
        # Skip if this was already captured as a string
        if not any(f'"{key}":' in pair for pair in pairs):
            pairs.append(f'"{key}": {value}')
    
    if pairs:
        rebuilt_json = '{' + ', '.join(pairs) + '}'
        try:
            # Validate the rebuilt JSON
            json.loads(rebuilt_json)
            return rebuilt_json
        except json.JSONDecodeError:
            pass
    
    # If rebuild failed, return original
    return json_str


def fix_long_json_with_code(json_str: str) -> str:
    """
    Specialized method to fix long JSON strings that contain code, 
    particularly for edit_file tool calls.
    
    Args:
        json_str: Long JSON string that may contain code
        
    Returns:
        Fixed JSON string
    """
    try:
        # First, try to identify and fix the specific structure for edit_file
        # Common pattern: {"target_file": "...", "edit_mode": "...", "code_edit": "...long code..."}
        
        # Strategy: Find the main structure and carefully parse each field
        fixed_json = json_str.strip()
        
        # Remove any trailing/leading whitespace and ensure proper braces
        if not fixed_json.startswith('{'):
            fixed_json = '{' + fixed_json
        if not fixed_json.endswith('}'):
            fixed_json = fixed_json + '}'
        
        # Look for the pattern of edit_file parameters and fix them systematically
        # Pattern 1: Fix space between values and next keys (most common issue)
        # This handles: "value" "next_key" -> "value", "next_key"
        
        # Be more aggressive with comma insertion for known tool patterns
        edit_file_fixes = [
            # target_file followed by edit_mode
            (r'("target_file":\s*"[^"]*")\s+("edit_mode")', r'\1, \2'),
            # edit_mode followed by code_edit  
            (r'("edit_mode":\s*"[^"]*")\s+("code_edit")', r'\1, \2'),
            # Any quoted value followed by a key (more general)
            (r'(":\s*"[^"]*(?:\\.[^"]*)*")\s+("[\w_]+"\s*:)', r'\1, \2'),
            # Handle boolean/number values followed by keys
            (r'(":\s*(?:true|false|\d+))\s+("[\w_]+"\s*:)', r'\1, \2'),
        ]
        
        for pattern, replacement in edit_file_fixes:
            old_json = fixed_json
            fixed_json = re.sub(pattern, replacement, fixed_json, flags=re.DOTALL)
        
        # Try to validate and return
        try:
            json.loads(fixed_json)
            return fixed_json
        except json.JSONDecodeError:
            # If still failing, try more aggressive fixes
            pass
        
        # Fallback: Try to extract and rebuild key-value pairs manually
        # First, check if this is a tool call format with tool_name and parameters
        tool_name_match = re.search(r'"tool_name":\s*"([^"]*)"', fixed_json)
        tool_name = tool_name_match.group(1) if tool_name_match else None
        
        # Check if parameters structure exists
        parameters_match = re.search(r'"parameters":\s*\{', fixed_json)
        has_parameters_wrapper = parameters_match is not None
        
        # Extract parameters content (may be nested)
        if has_parameters_wrapper:
            # Find the parameters object boundaries
            params_start = fixed_json.find('"parameters":')
            if params_start != -1:
                # Find the opening brace after "parameters":
                brace_start = fixed_json.find('{', params_start)
                if brace_start != -1:
                    # Count braces to find matching closing brace
                    brace_count = 0
                    params_end = brace_start
                    for i in range(brace_start, len(fixed_json)):
                        char = fixed_json[i]
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                params_end = i + 1
                                break
                    params_content = fixed_json[brace_start:params_end]
                else:
                    params_content = None
            else:
                params_content = None
        else:
            params_content = fixed_json  # The whole JSON is the parameters
        
        # Extract individual parameter fields
        pairs = {}
        
        # Extract target_file
        target_match = re.search(r'"target_file":\s*"([^"]*)"', params_content if params_content else fixed_json)
        if target_match:
            pairs['target_file'] = target_match.group(1)
        
        # Extract edit_mode  
        mode_match = re.search(r'"edit_mode":\s*"([^"]*)"', params_content if params_content else fixed_json)
        if mode_match:
            pairs['edit_mode'] = mode_match.group(1)
        
        # Extract code_edit (this is the tricky one with potentially long content)
        # First, try to find code_edit field position
        code_edit_pattern = r'"code_edit":\s*"'
        code_edit_match = re.search(code_edit_pattern, params_content if params_content else fixed_json, re.DOTALL)
        
        if code_edit_match:
            # Find the start position after the opening quote
            start_pos = code_edit_match.end() - 1  # Position of the opening quote
            search_text = params_content if params_content else fixed_json
            
            # Try to find the matching closing quote, handling escaped quotes
            # But also handle cases where newlines are not escaped
            # Strategy: find the closing quote that's followed by } or comma or end of string
            # Look for pattern: " followed by whitespace and } or comma
            end_pattern = r'"\s*[,}]'
            end_match = re.search(end_pattern, search_text[start_pos + 1:], re.DOTALL)
            
            if end_match:
                # Found a closing quote followed by } or comma
                end_pos = start_pos + 1 + end_match.start()
                code_content = search_text[start_pos + 1:end_pos]
                # Unescape the content properly (handle already escaped characters)
                pairs['code_edit'] = code_content
            else:
                # No matching quote found, extract everything until the end or next field
                # Look for the next field pattern or end of JSON
                next_field_pattern = r'\s*"[\w_]+"\s*:'
                next_field_match = re.search(next_field_pattern, search_text[start_pos + 1:], re.DOTALL)
                if next_field_match:
                    end_pos = start_pos + 1 + next_field_match.start()
                    code_content = search_text[start_pos + 1:end_pos].rstrip().rstrip('"')
                    pairs['code_edit'] = code_content
                else:
                    # Extract until the end, removing trailing quote if present
                    code_content = search_text[start_pos + 1:].rstrip().rstrip('"').rstrip('}')
                    pairs['code_edit'] = code_content
        
        # If we found the key components, rebuild the JSON
        if len(pairs) >= 2:  # At least target_file and one other parameter
            # Properly escape the code_edit content if it exists
            if 'code_edit' in pairs:
                # Re-escape any unescaped characters in the code
                code = pairs['code_edit']
                code = code.replace('\\', '\\\\').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r').replace('"', '\\"')
                pairs['code_edit'] = code
            
            # Rebuild the parameters JSON
            rebuilt_parts = []
            for key, value in pairs.items():
                rebuilt_parts.append(f'"{key}": "{value}"')
            
            rebuilt_params_json = '{' + ', '.join(rebuilt_parts) + '}'
            
            # Rebuild the full tool call JSON if tool_name was found
            if tool_name:
                rebuilt_json = f'{{"tool_name": "{tool_name}", "parameters": {rebuilt_params_json}}}'
            else:
                # If no tool_name found, infer from parameters
                # Common patterns: edit_file has target_file and edit_mode/code_edit
                if 'target_file' in pairs and ('edit_mode' in pairs or 'code_edit' in pairs):
                    tool_name = 'edit_file'
                    rebuilt_json = f'{{"tool_name": "{tool_name}", "parameters": {rebuilt_params_json}}}'
                else:
                    # Just return parameters if we can't infer tool_name
                    rebuilt_json = rebuilt_params_json
            
            # Validate the rebuilt JSON
            try:
                json.loads(rebuilt_json)
                return rebuilt_json
            except json.JSONDecodeError:
                pass
        
        # If all else fails, return the input with basic comma fixes
        return fixed_json
        
    except Exception as e:
        return json_str


def parse_python_params_manually(params_str: str) -> Dict[str, Any]:
    """
    Manually parse Python function parameters when JSON parsing fails.
    
    Args:
        params_str: Parameter string from Python function call
        
    Returns:
        Dictionary of parameters
    """
    params = {}
    
    # Remove the outer braces if present
    if params_str.startswith('{') and params_str.endswith('}'):
        params_str = params_str[1:-1].strip()
    
    # Split by commas, but be careful about commas inside strings
    param_parts = []
    current_part = ""
    in_quotes = False
    quote_char = None
    brace_depth = 0
    
    for char in params_str:
        if char in ('"', "'") and not in_quotes:
            in_quotes = True
            quote_char = char
            current_part += char
        elif char == quote_char and in_quotes:
            in_quotes = False
            quote_char = None
            current_part += char
        elif char == '{' and not in_quotes:
            brace_depth += 1
            current_part += char
        elif char == '}' and not in_quotes:
            brace_depth -= 1
            current_part += char
        elif char == ',' and not in_quotes and brace_depth == 0:
            param_parts.append(current_part.strip())
            current_part = ""
        else:
            current_part += char
    
    if current_part.strip():
        param_parts.append(current_part.strip())
    
    # Parse each parameter
    for part in param_parts:
        # Look for key: value pattern
        if ':' in part:
            key_value = part.split(':', 1)
            if len(key_value) == 2:
                key = key_value[0].strip().strip('"\'')
                value = key_value[1].strip()
                
                # Remove quotes from value if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                # Convert boolean values
                if value.lower() in ('true', 'false'):
                    value = value.lower() == 'true'
                # Convert numeric values
                elif value.isdigit():
                    value = int(value)
                
                params[key] = value
    
    return params


def convert_parameter_value(value: str) -> Any:
    """
    Convert parameter value to appropriate type.
    
    Args:
        value: String value to convert
        
    Returns:
        Converted value (string, int, bool, list, etc.)
    """
    # For certain parameters that may contain meaningful whitespace/formatting,
    # don't strip the value
    value_stripped = value.strip()
    
    # Handle boolean values
    if value_stripped.lower() in ('true', 'false'):
        return value_stripped.lower() == 'true'
    
    # Handle integers
    if value_stripped.isdigit():
        return int(value_stripped)
    
    # Handle negative integers
    if value_stripped.startswith('-') and value_stripped[1:].isdigit():
        return int(value_stripped)
    
    # Handle JSON arrays/objects
    if (value_stripped.startswith('[') and value_stripped.endswith(']')) or (value_stripped.startswith('{') and value_stripped.endswith('}')):
        try:
            return json.loads(value_stripped)
        except json.JSONDecodeError:
            pass
    
    # Return original value (not stripped) for string parameters to preserve formatting
    return value


def generate_tools_prompt_from_json(tool_definitions: Dict[str, Any], language: str = 'en') -> str:
    """
    Generate tools prompt string from JSON tool definitions for chat-based models.
    
    Args:
        tool_definitions: Dictionary of tool definitions loaded from JSON
        language: Language code ('zh' for Chinese, 'en' for English)
        
    Returns:
        Formatted string containing tool descriptions for chat-based models
    """
    try:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
        
        if not tool_definitions:
            return ""
        
        prompt_parts = []
        
        # Add header
        if language == 'zh':
            prompt_parts.append("## Available tools")
            prompt_parts.append("")
            prompt_parts.append("You can use the following tools to complete tasks. Please use JSON format to call tools:")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "Tool name",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "Parameter name": "Parameter value"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### Tool list:")
        else:
            prompt_parts.append("## Available Tools")
            prompt_parts.append("")
            prompt_parts.append("You can use the following tools to complete tasks. Please call tools using JSON format:")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "tool_name",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "param_name": "param_value"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### Tool List:")
        
        prompt_parts.append("")
        
        # Add each tool's description
        for tool_name, tool_def in sorted(tool_definitions.items()):
            description = tool_def.get('description', 'No description available')
            parameters = tool_def.get('parameters', {})
            properties = parameters.get('properties', {})
            required = parameters.get('required', [])
            
            # Tool header
            prompt_parts.append(f"#### {tool_name}")
            prompt_parts.append(f"**Description**: {description}" if language == 'zh' else f"**Description**: {description}")
            prompt_parts.append("")
            
            # Parameters
            if properties:
                prompt_parts.append("**Parameters**:" if language == 'zh' else "**Parameters**:")
                for param_name, param_def in properties.items():
                    param_type = param_def.get('type', 'string')
                    param_desc = param_def.get('description', 'No description')
                    param_required = param_name in required
                    required_marker = " (Required)" if language == 'zh' else " (required)" if param_required else ""
                    
                    # Handle array type
                    if param_type == 'array':
                        items_type = param_def.get('items', {}).get('type', 'string')
                        param_type = f"array[{items_type}]"
                    
                    prompt_parts.append(f"- `{param_name}` ({param_type}){required_marker}: {param_desc}")
                
                prompt_parts.append("")
            else:
                prompt_parts.append("**Parameters**: None" if language == 'zh' else "**Parameters**: None")
                prompt_parts.append("")
            
            # Example usage
            if language == 'zh':
                prompt_parts.append("**Usage Example**:")
            else:
                prompt_parts.append("**Example Usage**:")
            
            # Generate example based on tool
            example_params = {}
            for param_name, param_def in properties.items():
                if param_name in required:
                    param_type = param_def.get('type', 'string')
                    if param_type == 'string':
                        example_params[param_name] = "example_value"
                    elif param_type == 'integer':
                        example_params[param_name] = 1
                    elif param_type == 'boolean':
                        example_params[param_name] = True
                    elif param_type == 'array':
                        example_params[param_name] = ["item1", "item2"]
                    elif param_type == 'object':
                        example_params[param_name] = {"key": "value"}
            
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append(f'  "tool_name": "{tool_name}",')
            prompt_parts.append('  "parameters": {')
            
            if example_params:
                param_lines = []
                for key, value in example_params.items():
                    if isinstance(value, str):
                        param_lines.append(f'    "{key}": "{value}"')
                    else:
                        import json
                        param_lines.append(f'    "{key}": {json.dumps(value)}')
                prompt_parts.append(',\n'.join(param_lines))
            
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("---")
            prompt_parts.append("")
        
        # Add footer instructions
        if language == 'zh':
            prompt_parts.append("### Important notes:")
            prompt_parts.append("1. Please strictly follow the above JSON format to call tools")
            prompt_parts.append("2. Tool name must match exactly")
            prompt_parts.append("3. Required parameters cannot be omitted")
            prompt_parts.append("4. Parameter types must be correct")
            prompt_parts.append("5. Multiple tools can be called simultaneously")
        else:
            prompt_parts.append("### Important Notes:")
            prompt_parts.append("1. Please strictly follow the JSON format above for tool calls")
            prompt_parts.append("2. Tool names must match exactly")
            prompt_parts.append("3. Required parameters cannot be omitted")
            prompt_parts.append("4. Parameter types must be correct")
            prompt_parts.append("5. Multiple tools can be called simultaneously")
        
        return "\n".join(prompt_parts)
        
    except Exception as e:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
                
        print_current(f"⚠️  Error generating tools prompt from JSON: {e}")
        return ""


# Convenience function aliases for backward compatibility
_fix_json_escapes = fix_json_escapes
_smart_escape_quotes_in_json_values = smart_escape_quotes_in_json_values  
_rebuild_json_structure = rebuild_json_structure
_fix_long_json_with_code = fix_long_json_with_code
_parse_python_params_manually = parse_python_params_manually
_convert_parameter_value = convert_parameter_value 