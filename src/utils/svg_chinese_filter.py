#!/usr/bin/env python3
"""
Simplified SVG Chinese font repair filter
Specifically handles SVG charts containing Chinese generated by tools like Mermaid
"""

import mimetypes
import subprocess
import os
import sys
import re
import tempfile
from pandocfilters import toJSONFilter, Image


def convert_foreign_objects_to_text(svg_content):
    """Convert text in foreignObject to standard SVG text elements"""
    def extract_text_from_html(html_content):
        # Remove HTML tags
        text = re.sub(r'<[^>]+>', '', html_content)
        return ' '.join(text.split()).strip()
    
    def replace_foreign_object(match):
        full_match = match.group(0)
        
        # Extract position and size
        x = float(re.search(r'x\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'x\s*=\s*["\']([^"\']+)["\']', full_match) else 0
        y = float(re.search(r'y\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'y\s*=\s*["\']([^"\']+)["\']', full_match) else 0
        width = float(re.search(r'width\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'width\s*=\s*["\']([^"\']+)["\']', full_match) else 100
        height = float(re.search(r'height\s*=\s*["\']([^"\']+)["\']', full_match).group(1)) if re.search(r'height\s*=\s*["\']([^"\']+)["\']', full_match) else 24
        
        # Extract text content
        content_match = re.search(r'<foreignObject[^>]*>(.*?)</foreignObject>', full_match, re.DOTALL)
        if not content_match:
            return ''
            
        inner_content = content_match.group(1)
        text_content = extract_text_from_html(inner_content)
        
        if not text_content:
            return ''
        
        # Generate text element
        text_x = x + width / 2
        text_y = y + height / 2 + 6
        
        return f'''<text x="{text_x}" y="{text_y}" text-anchor="middle" dominant-baseline="central" font-family="Noto Sans CJK SC, WenQuanYi Micro Hei, sans-serif" font-size="16" fill="#333">{text_content}</text>'''
    
    # Replace all foreignObject
    pattern = r'<foreignObject[^>]*>.*?</foreignObject>'
    result = re.sub(pattern, replace_foreign_object, svg_content, flags=re.DOTALL | re.IGNORECASE)
    return result


def add_chinese_font_support(svg_content):
    """Add Chinese font support for SVG"""
    # Add CJK font styles with higher specificity
    cjk_style = '''<style type="text/css">
svg, text, tspan, .taskText, .sectionTitle, .titleText {
    font-family: "Noto Sans CJK SC", "Noto Serif CJK SC", "WenQuanYi Micro Hei", "SimHei", "Microsoft YaHei", sans-serif !important;
}
* {
    font-family: "Noto Sans CJK SC", "Noto Serif CJK SC", "WenQuanYi Micro Hei", "SimHei", "Microsoft YaHei", sans-serif !important;
}
</style>'''

    # Insert styles after <svg> tag
    def insert_style(match):
        return match.group(1) + cjk_style

    result, num = re.subn(r'(<svg[^>]*>)', insert_style, svg_content, count=1, flags=re.IGNORECASE)
    if num == 0:
        result = cjk_style + svg_content

    # Also replace any inline font-family attributes
    result = re.sub(
        r'font-family="[^"]*"',
        'font-family="Noto Sans CJK SC, WenQuanYi Micro Hei, SimHei, Microsoft YaHei, sans-serif"',
        result,
        flags=re.IGNORECASE
    )

    # For text elements without font-family, add it explicitly
    # Only add to text elements that don't already have font-family
    def add_font_to_text(match):
        text_tag = match.group(1)
        if 'font-family' not in text_tag:
            return text_tag + ' font-family="Noto Sans CJK SC, WenQuanYi Micro Hei, SimHei, Microsoft YaHei, sans-serif"' + match.group(2)
        else:
            return match.group(0)

    result = re.sub(
        r'(<text[^>]*)(>)',
        add_font_to_text,
        result,
        flags=re.IGNORECASE
    )

    return result


def convert_svg_to_pdf(svg_path, pdf_path):
    """Use CairoSVG to convert SVG to PDF"""
    try:
        import cairosvg
        cairosvg.svg2pdf(url=svg_path, write_to=pdf_path)
        return True
    except ImportError:
        sys.stderr.write("CairoSVG not available, trying Inkscape...\n")
        return convert_with_inkscape(svg_path, pdf_path)
    except Exception as e:
        sys.stderr.write(f"CairoSVG conversion failed: {e}\n")
        return convert_with_inkscape(svg_path, pdf_path)


def convert_with_inkscape(svg_path, pdf_path):
    """Use Inkscape conversion (backup plan)"""
    import shutil
    inkscape = shutil.which('inkscape')
    if not inkscape:
        return False
    
    try:
        cmd = [inkscape, svg_path, '--export-type=pdf', '--export-text-to-path', f'--export-filename={pdf_path}']
        result = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return result == 0
    except Exception:
        return False


def generate_title_from_filename(src):
    """Generate appropriate title based on filename"""
    import os
    # Get filename (without path and extension)
    base_name = os.path.splitext(os.path.basename(src))[0]
    
    # If it's a SHA-encoded filename (starting with mermaid_sha)
    if base_name.startswith('mermaid_sha'):
        return None
    
    # New logic: directly use filename as title
    # Filename has been sanitized
    title = base_name.replace('_', ' ')
    return title

def process_svg_file(src):
    """Process SVG file, convert to PDF and return PDF filename"""
    # Check if it's an SVG file
    mime_type, _ = mimetypes.guess_type(src)
    if mime_type != 'image/svg+xml':
        return None
        
    base_name, _ = os.path.splitext(src)
    pdf_name = base_name + ".pdf"
    
    # Check if regeneration is needed
    try:
        pdf_mtime = os.path.getmtime(pdf_name)
    except OSError:
        pdf_mtime = -1
        
    if pdf_mtime < os.path.getmtime(src):
        # Process SVG file
        try:
            with open(src, 'r', encoding='utf-8') as f:
                svg_content = f.read()
            
            # Convert foreignObject to text element
            svg_content = convert_foreign_objects_to_text(svg_content)
            
            # Add Chinese font support
            svg_content = add_chinese_font_support(svg_content)
            
            # Create temporary file
            with tempfile.NamedTemporaryFile('w', suffix='.svg', delete=False, encoding='utf-8') as tmp_file:
                tmp_file.write(svg_content)
                temp_svg = tmp_file.name
            
            try:
                # Convert to PDF
                success = convert_svg_to_pdf(temp_svg, pdf_name)
                if success:
                    sys.stderr.write(f"Successfully converted {src} to {pdf_name}\n")
                    return pdf_name
                else:
                    sys.stderr.write(f"Failed to convert {src}\n")
                    return None
            finally:
                # Clean up temporary files
                if os.path.exists(temp_svg):
                    os.remove(temp_svg)
        except Exception as e:
            sys.stderr.write(f"Error processing {src}: {e}\n")
            return None
    
    return pdf_name


def svg_to_pdf_filter(key, value, fmt, meta):
    """Pandoc filter main function"""
    
    # Process RawInline HTML img tags (for Mermaid charts)
    if key == 'RawInline' and fmt in ['latex', 'beamer']:
        format_type, content = value
        if format_type == 'html' and '<img' in content and '.svg' in content:
            # Extract src attribute from HTML img tag
            src_match = re.search(r'src=["\']([^"\']*\.svg)["\']', content)
            alt_match = re.search(r'alt=["\']([^"\']*)["\']', content)
            
            if src_match:
                src = src_match.group(1)
                alt = alt_match.group(1) if alt_match else ""
                
                # Process SVG to PDF conversion
                pdf_name = process_svg_file(src)
                if pdf_name:
                    from pandocfilters import Str
                    # Use alt text if available and meaningful, otherwise fall back to filename
                    if alt and alt.strip() and not alt.strip().startswith('svg_'):
                        # Use alt text from HTML img tag as caption
                        return Image(['', [], []], [Str(alt)], [pdf_name, "fig:"])
                    else:
                        # Fall back to filename-based title
                        title = generate_title_from_filename(src)
                        if title:
                            # Use filename as title
                            return Image(['', [], []], [Str(title)], [pdf_name, "fig:"])
                        else:
                            # SHA-encoded filename, use alt if available
                            return Image(['', [], []], [Str(alt)] if alt else [Str("Figure")], [pdf_name, "fig:"])
    
    # Process standard Image element
    if key == 'Image' and fmt in ['latex', 'beamer']:
        attrs, alt, [src, title] = value
        
        # Check if it's an SVG file
        mime_type, _ = mimetypes.guess_type(src)
        if mime_type == 'image/svg+xml':
            base_name, _ = os.path.splitext(src)
            pdf_name = base_name + ".pdf"
            
            # Check if regeneration is needed
            try:
                pdf_mtime = os.path.getmtime(pdf_name)
            except OSError:
                pdf_mtime = -1
                
            if pdf_mtime < os.path.getmtime(src):
                # Process SVG file
                with open(src, 'r', encoding='utf-8') as f:
                    svg_content = f.read()
                
                # Convert foreignObject to text element
                svg_content = convert_foreign_objects_to_text(svg_content)
                
                # Add Chinese font support
                svg_content = add_chinese_font_support(svg_content)
                
                # Create temporary file
                with tempfile.NamedTemporaryFile('w', suffix='.svg', delete=False, encoding='utf-8') as tmp_file:
                    tmp_file.write(svg_content)
                    temp_svg = tmp_file.name
                
                try:
                    # Convert to PDF
                    success = convert_svg_to_pdf(temp_svg, pdf_name)
                    if success:
                        sys.stderr.write(f"Successfully converted {src} to {pdf_name}\n")
                    else:
                        sys.stderr.write(f"Failed to convert {src}\n")
                finally:
                    # Clean up temporary files
                    if os.path.exists(temp_svg):
                        os.remove(temp_svg)
            
            # Use alt text from markdown as caption if available and meaningful
            # alt is a list of inline elements, convert to string
            alt_text = ""
            if alt and len(alt) > 0:
                # Extract text from alt inline elements
                alt_parts = []
                for inline in alt:
                    if isinstance(inline, dict) and inline.get('t') == 'Str':
                        alt_parts.append(inline.get('c', ''))
                    elif isinstance(inline, str):
                        alt_parts.append(inline)
                alt_text = ''.join(alt_parts).strip()
            
            # Use alt text if available and meaningful, otherwise fall back to filename
            if alt_text and not alt_text.startswith('svg_'):
                # Use alt text from markdown as caption
                return Image(attrs, alt, [pdf_name, "fig:"])
            else:
                # Fall back to filename-based title
                filename_title = generate_title_from_filename(src)
                if filename_title:
                    # Use filename as title
                    return Image(attrs, [{"t": "Str", "c": filename_title}], [pdf_name, "fig:"])
                else:
                    # SHA-encoded filename, use alt if available
                    return Image(attrs, alt, [pdf_name, title])


if __name__ == "__main__":
    toJSONFilter(svg_to_pdf_filter)