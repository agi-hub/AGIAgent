#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
JSON parsing and fixing utilities.

This module contains utility functions for parsing and fixing malformed JSON strings,
particularly those generated by language models that may contain escape issues or
structural problems.

Migrated from tool_executor.py for better code organization and reusability.
"""

import json
import re
from typing import Dict, Any, Optional


def _log_warning(message: str) -> None:
    """
    Simple logging function to replace print_current dependency.
    
    Args:
        message: Warning message to log
    """
    try:
        # Try to import print_current if available
        from tools.print_system import print_current
        print_current(message)
    except ImportError:
        # Fallback to standard print if print_current is not available
        print(message)


def fix_json_escapes(json_str: str) -> str:
    """
    Fix common escape issues in JSON strings to make them valid JSON.
    
    Args:
        json_str: Raw JSON string that may have escape issues
        
    Returns:
        Fixed JSON string
    """
    try:
        # Try to parse as-is first - most of the time it's already valid
        json.loads(json_str)
        return json_str
    except json.JSONDecodeError as e:
        # Strategy 0: Smart quote escaping - escape all unescaped quotes in JSON values
        try:
            smart_fixed = smart_escape_quotes_in_json_values(json_str)
            if smart_fixed != json_str:
                json.loads(smart_fixed)
                return smart_fixed
        except json.JSONDecodeError:
            pass
        
        # Apply more comprehensive fixes for common issues
        fixed_json = json_str
        
        # Strategy 1: Fix unescaped characters in string values
        def fix_string_content(match):
            full_match = match.group(0)
            quote_char = match.group(1)  # Opening quote
            string_content = match.group(2)  # Content between quotes
            closing_quote = match.group(3)  # Closing quote
            
            # Fix unescaped control characters
            string_content = re.sub(r'(?<!\\)\n', '\\n', string_content)
            string_content = re.sub(r'(?<!\\)\t', '\\t', string_content)
            string_content = re.sub(r'(?<!\\)\r', '\\r', string_content)
            string_content = re.sub(r'(?<!\\)\b', '\\b', string_content)
            string_content = re.sub(r'(?<!\\)\f', '\\f', string_content)
            
            # Fix unescaped quotes (but not already escaped ones)
            if quote_char == '"':
                string_content = re.sub(r'(?<!\\)"', '\\"', string_content)
            
            # Fix unescaped backslashes (but not already escaped ones)
            string_content = re.sub(r'(?<!\\)\\(?![\\"/bfnrt])', '\\\\', string_content)
            
            return f'{quote_char}{string_content}{closing_quote}'
        
        # Apply fixes to quoted strings - improved pattern to handle multiline content
        string_pattern = r'(")((?:[^"\\]|\\.)*)(")'
        fixed_json = re.sub(string_pattern, fix_string_content, fixed_json, flags=re.DOTALL)
        
        try:
            # Test if our fixes worked
            json.loads(fixed_json)
            return fixed_json
        except json.JSONDecodeError as e2:
            # Strategy 2: Try to fix structural JSON issues
            # Look for missing commas between object properties
            fixed_json2 = fixed_json
            
            # Strategy 2a: Handle multiline strings specifically (common in code_edit parameters)
            # For cases like: "code_edit": "def function():\n    return 1" "edit_mode": "replace"
            # Pattern: multiline string value followed by key without comma
            multiline_pattern = r'(":\s*"[^"]*(?:\\.[^"]*)*")\s+("[\w_]+":)'
            fixed_json2 = re.sub(multiline_pattern, r'\1, \2', fixed_json2, flags=re.DOTALL)
            
            # Fix missing commas between key-value pairs with numbers/booleans
            comma_pattern2 = r'(":\s*(?:\d+|true|false|null))\s+("[\w_]+":)'
            fixed_json2 = re.sub(comma_pattern2, r'\1, \2', fixed_json2)
            
            # Fix missing commas between complex values
            comma_pattern3 = r'(})\s+("[\w_]+":)'
            fixed_json2 = re.sub(comma_pattern3, r'\1, \2', fixed_json2)
            
            # Special handling for edit_file tool parameters (common problematic case)
            # Look for patterns specific to edit_file: target_file, edit_mode, code_edit
            edit_file_pattern = r'("target_file":\s*"[^"]*")\s+("edit_mode":)'
            fixed_json2 = re.sub(edit_file_pattern, r'\1, \2', fixed_json2)
            
            edit_file_pattern2 = r'("edit_mode":\s*"[^"]*")\s+("code_edit":)'
            fixed_json2 = re.sub(edit_file_pattern2, r'\1, \2', fixed_json2)
            
            try:
                json.loads(fixed_json2)
                return fixed_json2
            except json.JSONDecodeError as e3:
                # Strategy 3: Specialized handling for long JSON with code content
                try:
                    specialized_fix = fix_long_json_with_code(json_str)
                    if specialized_fix != json_str:
                        json.loads(specialized_fix)
                        return specialized_fix
                except json.JSONDecodeError:
                    pass
                
                # Strategy 4: Last resort - try to rebuild the JSON structure
                try:
                    rebuilt = rebuild_json_structure(json_str)
                    if rebuilt != json_str:
                        return rebuilt
                except:
                    pass
                
                # If all else fails, return the original
                return json_str


def smart_escape_quotes_in_json_values(json_str: str) -> str:
    """
    Smart method to escape unescaped quotes in JSON values while preserving JSON structure.
    
    This method uses a simple but effective approach: find JSON values and escape quotes within them.
    
    Args:
        json_str: Raw JSON string that may have unescaped quotes in values
        
    Returns:
        JSON string with properly escaped quotes in values
    """
    try:
        # Simple but effective approach: 
        # Find patterns like "key": "value with "quotes" inside"
        # and escape the quotes inside the value
        
        # Step 1: Find all possible JSON value strings
        # This pattern captures: "field": "content that may contain "quotes""
        def escape_value_quotes(match):
            prefix = match.group(1)  # "field": "
            content = match.group(2)  # content that may contain quotes
            
            # Escape unescaped quotes in the content
            escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
            
            # Also escape other common problematic characters
            escaped_content = re.sub(r'(?<!\\)\n', '\\n', escaped_content)
            escaped_content = re.sub(r'(?<!\\)\t', '\\t', escaped_content)
            escaped_content = re.sub(r'(?<!\\)\r', '\\r', escaped_content)
            
            return f'{prefix}{escaped_content}'
        
        # Pattern to match JSON field values
        # Matches: "field": "value_content" but stops at the closing quote that's followed by , or }
        pattern = r'("[^"]*"\s*:\s*")(.*?)(?="(?:\s*[,}]))'
        
        fixed_json = re.sub(pattern, escape_value_quotes, json_str, flags=re.DOTALL)
        
        # Handle edge case: if the pattern didn't match properly, try a different approach
        if fixed_json == json_str:
            # Alternative approach: specifically target code_edit field which commonly has this issue
            code_edit_pattern = r'("code_edit"\s*:\s*")(.*?)("(?:\s*[,}]))'
            def fix_code_edit_quotes(match):
                prefix = match.group(1)
                content = match.group(2)
                suffix = match.group(3)
                escaped_content = re.sub(r'(?<!\\)"', '\\"', content)
                return f'{prefix}{escaped_content}{suffix}'
            
            fixed_json = re.sub(code_edit_pattern, fix_code_edit_quotes, json_str, flags=re.DOTALL)
        
        return fixed_json
        
    except Exception as e:
        _log_warning(f"⚠️ Error in smart quote escaping: {e}")
        # Ultimate fallback: target the most common problematic patterns
        try:
            fixed = json_str
            
            # Common Python code patterns that cause issues
            patterns_to_fix = [
                (r'if __name__ == "__main__"', r'if __name__ == \"__main__\"'),
                (r'print\("([^"]*)"', r'print(\"\\1\"'),
                (r'input\("([^"]*)"', r'input(\"\\1\"'),
                (r'open\("([^"]*)"', r'open(\"\\1\"'),
                (r'== "__main__"', r'== \"__main__\"'),
                (r'!= "__main__"', r'!= \"__main__\"'),
            ]
            
            for pattern, replacement in patterns_to_fix:
                fixed = re.sub(pattern, replacement, fixed)
            
            return fixed
            
        except Exception:
            return json_str


def rebuild_json_structure(json_str: str) -> str:
    """
    Last resort method to rebuild JSON structure from malformed JSON.
    
    Args:
        json_str: Malformed JSON string
        
    Returns:
        Rebuilt JSON string
    """
    # Try to extract key-value pairs and rebuild the JSON
    # This is a very basic approach for specific cases
    
    # Look for pattern: "key": "value" or "key": value
    pairs = []
    
    # Extract string values
    string_pattern = r'"([^"]+)":\s*"([^"]*(?:\\.[^"]*)*)"'
    for match in re.finditer(string_pattern, json_str, re.DOTALL):
        key = match.group(1)
        value = match.group(2)
        # Escape the value properly
        value = value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r')
        pairs.append(f'"{key}": "{value}"')
    
    # Extract non-string values (numbers, booleans, null)
    non_string_pattern = r'"([^"]+)":\s*([^",}\s]+)'
    for match in re.finditer(non_string_pattern, json_str):
        key = match.group(1)
        value = match.group(2).strip()
        # Skip if this was already captured as a string
        if not any(f'"{key}":' in pair for pair in pairs):
            pairs.append(f'"{key}": {value}')
    
    if pairs:
        rebuilt_json = '{' + ', '.join(pairs) + '}'
        try:
            # Validate the rebuilt JSON
            json.loads(rebuilt_json)
            return rebuilt_json
        except json.JSONDecodeError:
            pass
    
    # If rebuild failed, return original
    return json_str


def fix_long_json_with_code(json_str: str) -> str:
    """
    Specialized method to fix long JSON strings that contain code, 
    particularly for edit_file tool calls.
    
    Args:
        json_str: Long JSON string that may contain code
        
    Returns:
        Fixed JSON string
    """
    try:
        # First, try to identify and fix the specific structure for edit_file
        # Common pattern: {"target_file": "...", "edit_mode": "...", "code_edit": "...long code..."}
        
        # Strategy: Find the main structure and carefully parse each field
        fixed_json = json_str.strip()
        
        # Remove any trailing/leading whitespace and ensure proper braces
        if not fixed_json.startswith('{'):
            fixed_json = '{' + fixed_json
        if not fixed_json.endswith('}'):
            fixed_json = fixed_json + '}'
        
        # Look for the pattern of edit_file parameters and fix them systematically
        # Pattern 1: Fix space between values and next keys (most common issue)
        # This handles: "value" "next_key" -> "value", "next_key"
        
        # Be more aggressive with comma insertion for known tool patterns
        edit_file_fixes = [
            # target_file followed by edit_mode
            (r'("target_file":\s*"[^"]*")\s+("edit_mode")', r'\1, \2'),
            # edit_mode followed by code_edit  
            (r'("edit_mode":\s*"[^"]*")\s+("code_edit")', r'\1, \2'),
            # Any quoted value followed by a key (more general)
            (r'(":\s*"[^"]*(?:\\.[^"]*)*")\s+("[\w_]+"\s*:)', r'\1, \2'),
            # Handle boolean/number values followed by keys
            (r'(":\s*(?:true|false|\d+))\s+("[\w_]+"\s*:)', r'\1, \2'),
        ]
        
        for pattern, replacement in edit_file_fixes:
            old_json = fixed_json
            fixed_json = re.sub(pattern, replacement, fixed_json, flags=re.DOTALL)
        
        # Try to validate and return
        try:
            json.loads(fixed_json)
            return fixed_json
        except json.JSONDecodeError:
            # If still failing, try more aggressive fixes
            pass
        
        # Fallback: Try to extract and rebuild key-value pairs manually
        # This is specifically for edit_file tool calls
        pairs = {}
        
        # Extract target_file
        target_match = re.search(r'"target_file":\s*"([^"]*)"', fixed_json)
        if target_match:
            pairs['target_file'] = target_match.group(1)
        
        # Extract edit_mode  
        mode_match = re.search(r'"edit_mode":\s*"([^"]*)"', fixed_json)
        if mode_match:
            pairs['edit_mode'] = mode_match.group(1)
        
        # Extract code_edit (this is the tricky one with potentially long content)
        code_match = re.search(r'"code_edit":\s*"((?:[^"\\]|\\.)*)"\s*}?\s*$', fixed_json, re.DOTALL)
        if code_match:
            code_content = code_match.group(1)
            # Unescape the content properly
            pairs['code_edit'] = code_content
        
        # If we found the key components, rebuild the JSON
        if len(pairs) >= 2:  # At least target_file and one other parameter
            # Properly escape the code_edit content if it exists
            if 'code_edit' in pairs:
                # Re-escape any unescaped characters in the code
                code = pairs['code_edit']
                code = code.replace('\\', '\\\\').replace('\n', '\\n').replace('\t', '\\t').replace('\r', '\\r').replace('"', '\\"')
                pairs['code_edit'] = code
            
            # Rebuild the JSON
            rebuilt_parts = []
            for key, value in pairs.items():
                rebuilt_parts.append(f'"{key}": "{value}"')
            
            rebuilt_json = '{' + ', '.join(rebuilt_parts) + '}'
            
            # Validate the rebuilt JSON
            try:
                json.loads(rebuilt_json)
                return rebuilt_json
            except json.JSONDecodeError:
                pass
        
        # If all else fails, return the input with basic comma fixes
        return fixed_json
        
    except Exception as e:
        return json_str


def parse_python_params_manually(params_str: str) -> Dict[str, Any]:
    """
    Manually parse Python function parameters when JSON parsing fails.
    
    Args:
        params_str: Parameter string from Python function call
        
    Returns:
        Dictionary of parameters
    """
    params = {}
    
    # Remove the outer braces if present
    if params_str.startswith('{') and params_str.endswith('}'):
        params_str = params_str[1:-1].strip()
    
    # Split by commas, but be careful about commas inside strings
    param_parts = []
    current_part = ""
    in_quotes = False
    quote_char = None
    brace_depth = 0
    
    for char in params_str:
        if char in ('"', "'") and not in_quotes:
            in_quotes = True
            quote_char = char
            current_part += char
        elif char == quote_char and in_quotes:
            in_quotes = False
            quote_char = None
            current_part += char
        elif char == '{' and not in_quotes:
            brace_depth += 1
            current_part += char
        elif char == '}' and not in_quotes:
            brace_depth -= 1
            current_part += char
        elif char == ',' and not in_quotes and brace_depth == 0:
            param_parts.append(current_part.strip())
            current_part = ""
        else:
            current_part += char
    
    if current_part.strip():
        param_parts.append(current_part.strip())
    
    # Parse each parameter
    for part in param_parts:
        # Look for key: value pattern
        if ':' in part:
            key_value = part.split(':', 1)
            if len(key_value) == 2:
                key = key_value[0].strip().strip('"\'')
                value = key_value[1].strip()
                
                # Remove quotes from value if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                # Convert boolean values
                if value.lower() in ('true', 'false'):
                    value = value.lower() == 'true'
                # Convert numeric values
                elif value.isdigit():
                    value = int(value)
                
                params[key] = value
    
    return params


def convert_parameter_value(value: str) -> Any:
    """
    Convert parameter value to appropriate type.
    
    Args:
        value: String value to convert
        
    Returns:
        Converted value (string, int, bool, list, etc.)
    """
    # For certain parameters that may contain meaningful whitespace/formatting,
    # don't strip the value
    value_stripped = value.strip()
    
    # Handle boolean values
    if value_stripped.lower() in ('true', 'false'):
        return value_stripped.lower() == 'true'
    
    # Handle integers
    if value_stripped.isdigit():
        return int(value_stripped)
    
    # Handle negative integers
    if value_stripped.startswith('-') and value_stripped[1:].isdigit():
        return int(value_stripped)
    
    # Handle JSON arrays/objects
    if (value_stripped.startswith('[') and value_stripped.endswith(']')) or (value_stripped.startswith('{') and value_stripped.endswith('}')):
        try:
            return json.loads(value_stripped)
        except json.JSONDecodeError:
            pass
    
    # Return original value (not stripped) for string parameters to preserve formatting
    return value


def generate_tools_prompt_from_json(tool_definitions: Dict[str, Any], language: str = 'en') -> str:
    """
    Generate tools prompt string from JSON tool definitions for chat-based models.
    
    Args:
        tool_definitions: Dictionary of tool definitions loaded from JSON
        language: Language code ('zh' for Chinese, 'en' for English)
        
    Returns:
        Formatted string containing tool descriptions for chat-based models
    """
    try:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
        
        if not tool_definitions:
            return ""
        
        prompt_parts = []
        
        # Add header
        if language == 'zh':
            prompt_parts.append("## 可用工具")
            prompt_parts.append("")
            prompt_parts.append("您可以使用以下工具来完成任务。请使用JSON格式调用工具：")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "工具名称",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "参数名": "参数值"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### 工具列表：")
        else:
            prompt_parts.append("## Available Tools")
            prompt_parts.append("")
            prompt_parts.append("You can use the following tools to complete tasks. Please call tools using JSON format:")
            prompt_parts.append("")
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append('  "tool_name": "tool_name",')
            prompt_parts.append('  "parameters": {')
            prompt_parts.append('    "param_name": "param_value"')
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("### Tool List:")
        
        prompt_parts.append("")
        
        # Add each tool's description
        for tool_name, tool_def in sorted(tool_definitions.items()):
            description = tool_def.get('description', 'No description available')
            parameters = tool_def.get('parameters', {})
            properties = parameters.get('properties', {})
            required = parameters.get('required', [])
            
            # Tool header
            prompt_parts.append(f"#### {tool_name}")
            prompt_parts.append(f"**描述**: {description}" if language == 'zh' else f"**Description**: {description}")
            prompt_parts.append("")
            
            # Parameters
            if properties:
                prompt_parts.append("**参数**:" if language == 'zh' else "**Parameters**:")
                for param_name, param_def in properties.items():
                    param_type = param_def.get('type', 'string')
                    param_desc = param_def.get('description', 'No description')
                    param_required = param_name in required
                    required_marker = " (必需)" if language == 'zh' else " (required)" if param_required else ""
                    
                    # Handle array type
                    if param_type == 'array':
                        items_type = param_def.get('items', {}).get('type', 'string')
                        param_type = f"array[{items_type}]"
                    
                    prompt_parts.append(f"- `{param_name}` ({param_type}){required_marker}: {param_desc}")
                
                prompt_parts.append("")
            else:
                prompt_parts.append("**参数**: 无" if language == 'zh' else "**Parameters**: None")
                prompt_parts.append("")
            
            # Example usage
            if language == 'zh':
                prompt_parts.append("**使用示例**:")
            else:
                prompt_parts.append("**Example Usage**:")
            
            # Generate example based on tool
            example_params = {}
            for param_name, param_def in properties.items():
                if param_name in required:
                    param_type = param_def.get('type', 'string')
                    if param_type == 'string':
                        example_params[param_name] = "example_value"
                    elif param_type == 'integer':
                        example_params[param_name] = 1
                    elif param_type == 'boolean':
                        example_params[param_name] = True
                    elif param_type == 'array':
                        example_params[param_name] = ["item1", "item2"]
                    elif param_type == 'object':
                        example_params[param_name] = {"key": "value"}
            
            prompt_parts.append("```json")
            prompt_parts.append("{")
            prompt_parts.append(f'  "tool_name": "{tool_name}",')
            prompt_parts.append('  "parameters": {')
            
            if example_params:
                param_lines = []
                for key, value in example_params.items():
                    if isinstance(value, str):
                        param_lines.append(f'    "{key}": "{value}"')
                    else:
                        import json
                        param_lines.append(f'    "{key}": {json.dumps(value)}')
                prompt_parts.append(',\n'.join(param_lines))
            
            prompt_parts.append("  }")
            prompt_parts.append("}")
            prompt_parts.append("```")
            prompt_parts.append("")
            prompt_parts.append("---")
            prompt_parts.append("")
        
        # Add footer instructions
        if language == 'zh':
            prompt_parts.append("### 重要说明：")
            prompt_parts.append("1. 请严格按照上述JSON格式调用工具")
            prompt_parts.append("2. 工具名称必须完全匹配")
            prompt_parts.append("3. 必需参数不能省略")
            prompt_parts.append("4. 参数类型必须正确")
            prompt_parts.append("5. 可以同时调用多个工具")
        else:
            prompt_parts.append("### Important Notes:")
            prompt_parts.append("1. Please strictly follow the JSON format above for tool calls")
            prompt_parts.append("2. Tool names must match exactly")
            prompt_parts.append("3. Required parameters cannot be omitted")
            prompt_parts.append("4. Parameter types must be correct")
            prompt_parts.append("5. Multiple tools can be called simultaneously")
        
        return "\n".join(prompt_parts)
        
    except Exception as e:
        # For safety, import print_current here to avoid circular imports
        try:
            from tools.print_system import print_current
        except ImportError:
            def print_current(msg):
                print(msg)
                
        print_current(f"⚠️  Error generating tools prompt from JSON: {e}")
        return ""


# Convenience function aliases for backward compatibility
_fix_json_escapes = fix_json_escapes
_smart_escape_quotes_in_json_values = smart_escape_quotes_in_json_values  
_rebuild_json_structure = rebuild_json_structure
_fix_long_json_with_code = fix_long_json_with_code
_parse_python_params_manually = parse_python_params_manually
_convert_parameter_value = convert_parameter_value 